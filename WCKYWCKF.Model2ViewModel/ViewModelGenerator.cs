using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using static System.String;

namespace WCKYWCKF.RxUI.Model2ViewModel;

internal enum GenerateMode
{
    Default,
    RxUI,
    CommunityMvvm
}

internal record ViewModelGenerationInfo(
    string Namespace,
    GenerateMode GenerateMode,
    List<INamedTypeSymbol> ViewModelBuildInfos,
    List<ViewModelIgnoreGenerationInfo> GenerateViewModelIgnoreInfos,
    List<ViewModelReplaceGenerationInfo> GenerateViewModelReplaceInfos);

internal record ViewModelBuildInfo(
    string ClassName,
    string Namespace,
    List<PropertyBuildInfo> PropertyNames
);

internal record PropertyBuildInfo(string PropertyName, string TypeFullName, bool IsList = false);

internal record ViewModelIgnoreGenerationInfo(
    string PropertyName,
    INamedTypeSymbol TargetModelType);

internal record ViewModelReplaceGenerationInfo(
    string PropertyName,
    INamedTypeSymbol TargetModelType,
    INamedTypeSymbol ReplaceWithType);

#pragma warning disable RS1038 RS1041
[Generator]
#pragma warning restore RS1038 RS1041
public class ViewModelGenerator : IIncrementalGenerator
{
    // private const string ReactiveObjectType = "ReactiveUI.ReactiveObject";
    private const string ObservableCollectionType = "System.Collections.ObjectModel.ObservableCollection<{0}>";

    // private const string ReadOnlyObservableCollectionType =
    //     "System.Collections.ObjectModel.ReadOnlyObservableCollection<{0}>";


    private const string GenerateViewModelFullName = "WCKYWCKF.Model2ViewModel.GenerateViewModelAttribute";
    private const string GenerateViewModelName = "GenerateViewModelAttribute";
    private const string GenerateViewModelIgnoreName = "GenerateViewModelIgnoreAttribute";
    private const string GenerateViewModelReplaceName = "GenerateViewModelReplaceAttribute";

    private const string GenerateViewModelsTemplate =
        """
        // <auto-generated/>
        #nullable enable

        {0};

        public partial class {1} : {2} {{
        {3}
        }}
        #nullable disable
        """;

    private const string GenerateViewModelPropertyTemplate =
        $$$"""
           {{{TabStr}}}private {0}? {1}; 
           {{{TabStr}}}public {2}? {3} {{
           {{{TabStr}}}{{{TabStr}}}get => {4};
           {{{TabStr}}}{{{TabStr}}}set {{
           {5}
           {{{TabStr}}}{{{TabStr}}}}}
           {{{TabStr}}}}}
           """;

    private const string TabStr = "    ";

    private static SymbolDisplayFormat GetFullNamespace { get; } = SymbolDisplayFormat.FullyQualifiedFormat
        .WithGlobalNamespaceStyle(SymbolDisplayGlobalNamespaceStyle.Omitted)
        .WithMiscellaneousOptions(
            SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier);

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx =>
            ctx.AddSource("WCKYWCKF.Model2ViewModel.ViewModelGenerator.Attributes.g.cs",
                GenerateAttributes()));

        var classDeclarations = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                GenerateViewModelFullName,
                Predicate,
                GetGenerateViewModelInfo)
            .Where(x => x is not null)
            .Collect();

        // var provider = context.CompilationProvider.Combine(classDeclarations);

        context.RegisterSourceOutput(classDeclarations, static (spc, source) => Execute(spc, source!));
    }

    public static T? GetNamedArgument<T>(AttributeData attributeData, string name, T? fallback = default)
    {
        if (TryGetNamedArgument(attributeData, name, out T? value)) return value;
        return fallback;
    }

    public static bool TryGetNamedArgument<T>(AttributeData attributeData, string name, out T? value)
    {
        foreach (var properties in attributeData.NamedArguments)
            if (properties.Key == name)
            {
                value = (T?)properties.Value.Value;

                return true;
            }

        value = default;

        return false;
    }

    private bool Predicate(SyntaxNode syntaxNode, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();
        return syntaxNode
            is ClassDeclarationSyntax { AttributeLists.Count: > 0 }
            or RecordDeclarationSyntax { AttributeLists.Count: > 0 };
    }

    private ViewModelGenerationInfo? GetGenerateViewModelInfo(
        GeneratorAttributeSyntaxContext generatorAttributeSyntaxContext,
        CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();
        if (generatorAttributeSyntaxContext.TargetNode is not TypeDeclarationSyntax typeDeclarationSyntax) return null;

        var symbol = generatorAttributeSyntaxContext.TargetSymbol;
        var attributeDatas = symbol.GetAttributes()
            .Where(x => x.AttributeClass?.ContainingNamespace
                .ToDisplayString(GetFullNamespace)
                .StartsWith("WCKYWCKF.Model2ViewModel") is true)
            .GroupBy(x => x.AttributeClass?.Name)
            .ToList();
        return new ViewModelGenerationInfo(
            symbol.ContainingNamespace.ToDisplayString(),
            getGenerateMode(),
            (attributeDatas.Find(x => x.Key is GenerateViewModelName)?
                .Select(x =>
                {
                    TryGetNamedArgument(x, "ModelType", out INamedTypeSymbol? modelType);
                    return modelType ?? null;
                })
                .Where(x => x is not null)
                .ToList() ?? [])!,
            (attributeDatas.Find(x => x.Key is GenerateViewModelIgnoreName)?.Select(x =>
            {
                TryGetNamedArgument(x, "PropertyName", out string? propertyName);
                TryGetNamedArgument(x, "ModelType", out INamedTypeSymbol? modelType);
                if (IsNullOrEmpty(propertyName) || modelType is null) return null;
                return new ViewModelIgnoreGenerationInfo(propertyName, modelType);
            }).ToList() ?? [])!,
            (attributeDatas.Find(x => x.Key is GenerateViewModelReplaceName)?.Select(x =>
            {
                TryGetNamedArgument(x, "PropertyName", out string? propertyName);
                TryGetNamedArgument(x, "ModelType", out INamedTypeSymbol? modelType);
                TryGetNamedArgument(x, "ReplaceWithType", out INamedTypeSymbol? replaceWithType);
                if (IsNullOrEmpty(propertyName)
                    || modelType is null
                    || replaceWithType is null) return null;
                return new ViewModelReplaceGenerationInfo(propertyName, modelType, replaceWithType);
            }).ToList() ?? [])!);

        GenerateMode getGenerateMode()
        {
            var typeName = typeDeclarationSyntax.BaseList?.Types[0].Type.ToString();
            typeName = typeName?[(typeName.LastIndexOf('.') + 1)..];
            return typeName switch
            {
                "ReactiveObject" => GenerateMode.RxUI,
                "ObservableObject" => GenerateMode.CommunityMvvm,
                _ => GenerateMode.Default
            };
        }
    }

    private static void Execute(
        SourceProductionContext context,
        ImmutableArray<ViewModelGenerationInfo> generateViewModelInfos)
    {
        var builtViewModels = new HashSet<ITypeSymbol>(SymbolEqualityComparer.Default);

        foreach (var info in generateViewModelInfos)
        {
            var viewModelBuildInfos = CreateViewModelBuildInfo(builtViewModels, info);

            foreach (var buildInfo in viewModelBuildInfos.Distinct(EqualityComparer<ViewModelBuildInfo>.Create(
                         (viewModelBuildInfo, buildInfo) => viewModelBuildInfo?.ClassName == buildInfo?.ClassName,
                         x => x.ClassName.GetHashCode())))
            {
                var fileStr = Format(GenerateViewModelsTemplate,
                    $"""
                     {info.GenerateMode switch {
                         GenerateMode.RxUI => "using ReactiveUI;",
                         GenerateMode.CommunityMvvm => "using CommunityToolkit.Mvvm.ComponentModel;",
                         _ => """
                              using System.ComponentModel;
                              using System.Runtime.CompilerServices;
                              """
                     }}

                     namespace {buildInfo.Namespace}
                     """,
                    GetClassName(buildInfo.ClassName),
                    info.GenerateMode switch
                    {
                        GenerateMode.RxUI => "global::ReactiveUI.ReactiveObject",
                        GenerateMode.CommunityMvvm => "global::CommunityToolkit.Mvvm.ComponentModel.ObservableObject",
                        _ => "global::System.ComponentModel.INotifyPropertyChanged"
                    },
                    CreateProperties(info.GenerateMode switch
                    {
                        GenerateMode.RxUI => (x, _, _) =>
                            $"{TabStr}{TabStr}{TabStr}this.RaiseAndSetIfChanged(ref {x}, value);",
                        GenerateMode.CommunityMvvm => (x, y, z) =>
                            $$$"""
                               {{{TabStr}}}{{{TabStr}}}{{{TabStr}}}if (!global::System.Collections.Generic.EqualityComparer<{{{y}}}?>.Default.Equals({{{x}}}, value))
                               {{{TabStr}}}{{{TabStr}}}{{{TabStr}}}{
                               {{{TabStr}}}{{{TabStr}}}{{{TabStr}}}    var t = {{{x}}};
                               {{{TabStr}}}{{{TabStr}}}{{{TabStr}}}    On{{{z}}}Changing(value);
                               {{{TabStr}}}{{{TabStr}}}{{{TabStr}}}    On{{{z}}}Changing(t, value);
                               {{{TabStr}}}{{{TabStr}}}{{{TabStr}}}    OnPropertyChanging();
                               {{{TabStr}}}{{{TabStr}}}{{{TabStr}}}    {{{x}}} = value;
                               {{{TabStr}}}{{{TabStr}}}{{{TabStr}}}    On{{{z}}}Changed(value);
                               {{{TabStr}}}{{{TabStr}}}{{{TabStr}}}    On{{{z}}}Changed(t, value);
                               {{{TabStr}}}{{{TabStr}}}{{{TabStr}}}    OnPropertyChanged();
                               {{{TabStr}}}{{{TabStr}}}{{{TabStr}}}}
                               """,
                        _ => (x, _, _) => $"{TabStr}{TabStr}{TabStr}SetField(ref {x}, value);"
                    }) + "\r\n" +
                    info.GenerateMode switch
                    {
                        GenerateMode.RxUI => "",
                        GenerateMode.CommunityMvvm => CreatePropertiesForCommunityMvvm(),
                        _ => """
                             public event PropertyChangedEventHandler? PropertyChanged;

                             protected virtual void OnPropertyChanged([CallerMemberName] string? propertyName = null)
                             {
                                 PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
                             }

                             protected bool SetField<T>(ref T field, T value, [CallerMemberName] string? propertyName = null)
                             {
                                 if (EqualityComparer<T>.Default.Equals(field, value)) return false;
                                 field = value;
                                 OnPropertyChanged(propertyName);
                                 return true;
                             }
                             """
                    });


                context.AddSource(buildInfo.ClassName, fileStr);
                continue;

                string CreatePropertiesForCommunityMvvm()
                {
                    StringBuilder builder = new();
                    var first = buildInfo.PropertyNames.FirstOrDefault();
                    if (first is null) return Empty;
                    builder.Append(Create(first));
                    builder.AppendLine("");
                    foreach (var propertyBuildInfo in buildInfo.PropertyNames.Skip(1))
                    {
                        builder.AppendLine("");
                        builder.AppendLine(Create(propertyBuildInfo));
                    }

                    return builder.ToString();

                    string Create(PropertyBuildInfo propertyBuildInfo)
                    {
                        return $"""
                                {TabStr}partial void On{propertyBuildInfo.PropertyName}Changing({propertyBuildInfo.TypeFullName}? value);
                                {TabStr}partial void On{propertyBuildInfo.PropertyName}Changing({propertyBuildInfo.TypeFullName}? oldValue, {propertyBuildInfo.TypeFullName}? newValue);
                                {TabStr}partial void On{propertyBuildInfo.PropertyName}Changed({propertyBuildInfo.TypeFullName}? value);
                                {TabStr}partial void On{propertyBuildInfo.PropertyName}Changed({propertyBuildInfo.TypeFullName}? oldValue, {propertyBuildInfo.TypeFullName}? newValue);
                                """;
                    }
                }

                string CreateProperties(Func<string, string, string, string> setMethodStr)
                {
                    StringBuilder builder = new();
                    var first = buildInfo.PropertyNames.FirstOrDefault();
                    if (first is null) return Empty;
                    builder.Append(CreateProperty(first));
                    builder.AppendLine("");
                    foreach (var propertyBuildInfo in buildInfo.PropertyNames.Skip(1))
                    {
                        builder.AppendLine("");
                        builder.AppendLine(CreateProperty(propertyBuildInfo));
                    }

                    return builder.ToString();

                    string CreateProperty(PropertyBuildInfo propertyBuildInfo)
                    {
                        var field =
                            $"_{propertyBuildInfo.PropertyName[0].ToString().ToLower()}{propertyBuildInfo.PropertyName[1..]}";
                        return Format(GenerateViewModelPropertyTemplate,
                            propertyBuildInfo.TypeFullName,
                            field + (propertyBuildInfo.IsList ? " = new()" : Empty),
                            propertyBuildInfo.TypeFullName,
                            propertyBuildInfo.PropertyName,
                            field,
                            setMethodStr(field, propertyBuildInfo.TypeFullName, propertyBuildInfo.PropertyName));
                    }
                }
            }
        }
    }

    private static List<ViewModelBuildInfo> CreateViewModelBuildInfo(
        HashSet<ITypeSymbol> builtViewModels,
        ViewModelGenerationInfo viewModelGenerationInfo)
    {
        List<ViewModelBuildInfo> viewModelBuildInfos = [];
        Queue<ITypeSymbol> queue = new(viewModelGenerationInfo.ViewModelBuildInfos);
        while (queue.TryDequeue(out var typeSymbol))
        {
            if (builtViewModels.Contains(typeSymbol)
                || viewModelGenerationInfo.GenerateViewModelIgnoreInfos
                    .Where(x => IsNullOrEmpty(x.PropertyName))
                    .Any(x => SymbolEqualityComparer.Default.Equals(x.TargetModelType, typeSymbol))) continue;
            var list = typeSymbol.GetMembers()
                .OfType<IPropertySymbol>()
                .Where(x => x.IsStatic is false)
                .Where(x => x.DeclaredAccessibility is Accessibility.Public)
                .Where(x => !viewModelGenerationInfo.GenerateViewModelIgnoreInfos
                    .Where(y => IsNullOrEmpty(y.PropertyName))
                    .Any(y => SymbolEqualityComparer.Default.Equals(y.TargetModelType, x.Type)))
                .Select(x =>
                {
                    var propertyType = x.Type;
                    //处理类型替换
                    if (viewModelGenerationInfo.GenerateViewModelReplaceInfos.Find(y =>
                                y.TargetModelType.ToDisplayString() == typeSymbol.ToDisplayString())
                            is { } replaceInfo
                        && replaceInfo.PropertyName == x.Name)
                    {
                        propertyType = replaceInfo.ReplaceWithType;
                    }

                    //将列表替换为可观察列表（与处理类型替换不兼容）
                    else if (x.Type is INamedTypeSymbol namedTypeSymbol
                             && x.Type.AllInterfaces.Any(y =>
                                 y.MetadataName is "ICollection`1" or "IReadOnlyCollection`1"
                                 && y.ContainingNamespace.ToDisplayString(GetFullNamespace)
                                     .StartsWith("System.Collections"))
                             && !x.Type.AllInterfaces.Any(y => y.Name == nameof(INotifyCollectionChanged)))
                    {
                        var propertyTypeStr = CheckSGVM(namedTypeSymbol.TypeArguments[0]);
                        // propertyTypeStr = x.Type.AllInterfaces.Any(y => y.MetadataName is "ICollection`1")
                        //     ? string.Format(ObservableCollectionType, propertyTypeStr)
                        //     : string.Format(ReadOnlyObservableCollectionType, propertyTypeStr);
                        propertyTypeStr = Format(ObservableCollectionType, propertyTypeStr);
                        return new PropertyBuildInfo(x.Name, propertyTypeStr, true);
                    }

                    return new PropertyBuildInfo(x.Name, CheckSGVM(propertyType));
                });
            ViewModelBuildInfo viewModelBuildInfo = new(
                CheckSGVM(typeSymbol),
                viewModelGenerationInfo.Namespace,
                list.ToList());
            viewModelBuildInfos.Add(viewModelBuildInfo);
            builtViewModels.Add(typeSymbol);
        }

        return viewModelBuildInfos;

        //判断类型是否需要生成SGVM
        string CheckSGVM(ITypeSymbol symbol)
        {
            var propertyBuildInfo =
                symbol.TypeKind is TypeKind.Enum
                || symbol.ToDisplayString(GetFullNamespace).StartsWith("System")
                || symbol.AllInterfaces.Any(y => y.Name == nameof(INotifyPropertyChanged))
                    ? symbol.ToDisplayString(GetFullNamespace)
                    : GetSGVMTypeFullName();
            if (propertyBuildInfo.EndsWith("SGVM"))
                queue.Enqueue(symbol);
            return propertyBuildInfo.Replace("?", "");

            string GetSGVMTypeFullName()
            {
                var result = (symbol.ToDisplayString(GetFullNamespace).Replace("<", "_").Replace(">", "_") + "SGVM");
                return $"{viewModelGenerationInfo.Namespace}.{result[(result.LastIndexOf('.') + 1)..]}";
            }
        }
    }

    private static SourceText GenerateAttributes()
    {
        return SourceText.From(
            """
            // <auto-generated/>
            #nullable enable

            namespace WCKYWCKF.Model2ViewModel;

            [System.AttributeUsage(System.AttributeTargets.Class, AllowMultiple = true)]
            internal sealed class GenerateViewModelAttribute : System.Attribute
            {
                public required System.Type ModelType { get; init; }
                //public bool IgnoreReadOnly { get; init; }
            }

            [System.AttributeUsage(System.AttributeTargets.Class, AllowMultiple = true)]
            internal sealed class GenerateViewModelIgnoreAttribute : System.Attribute
            {
                public required System.Type ModelType { get; init; }
                public string PropertyName { get; init; } = "";
            }

            // [System.AttributeUsage(System.AttributeTargets.Class, AllowMultiple = true)]
            // internal sealed class GenerateViewModelPartialAttribute : System.Attribute
            // {
            //     public required System.Type ModelType { get; init; }
            //     public required string PropertyName { get; init; }
            // }

            [System.AttributeUsage(System.AttributeTargets.Class, AllowMultiple = true)]
            internal sealed class GenerateViewModelReplaceAttribute : System.Attribute
            {
                public required System.Type ModelType { get; init; }
                public required string PropertyName { get; init; }
                public required System.Type ReplaceWithType { get; init; }
            }
            #nullable disable
            """, Encoding.UTF8);
    }

    private static string GetClassName(string fullClassName)
    {
        return fullClassName[(fullClassName.LastIndexOf('.', fullClassName.Length - 3) + 1)..];
    }
}